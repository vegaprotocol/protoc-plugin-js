import join from '../../../utils/join.js'
import { enumerable } from 'protobuf-codec/encode/types.js'

const ENUM_ENCODING_MAX_BYTES = enumerable.encodingLength(enumerable.MAX_VALUE)

// Optimisation: "Dense" (string sequences without gaps) can be encoded as an array instead of map
// Optimisation: Longest common prefix can be removed and deferred to the string step
// Optimisation: encodingLength for groups of values, eg [0, 1, 2, 3], [1000, 1001, 1002]

export default function ({ name, values }) {
  const enumMaxValue = values.reduce((s, v) => Math.max(s, v.value), 0)
  const enumMinValue = values.reduce((s, v) => Math.min(s, v.value), 0)
  const enumMaxBytes = Math.max(enumerable.encodingLength(enumMaxValue), enumerable.encodingLength(enumMinValue))

  const enumMappingValues = JSON.stringify(values.flatMap(v => [[v.value, v.name]]))
  const enumMappingNames = JSON.stringify(values.flatMap(v => [[v.name, v.value]]))

  return join`
    /// autogenerated by protoc-plugin-js
    import assert from 'nanoassert'
    import { enumerable } from 'protobuf-codec/encode/types.js'
    import { enumerable as decodeEnumerable } from 'protobuf-codec/decode/types.js'

    ${values.map(v => `export const ${v.name} = ${v.value}`)}

    const enumValues = new Map(${enumMappingValues})
    const enumNames = new Map(${enumMappingNames})

    export function encode (value, buf, byteOffset = 0) {
      if (typeof value === 'string') return encode(parse(value), buf, byteOffset)
      if (value == null) throw new Error('Invalid ${name} value (' + value + ')')

      return enumerable.encode(value, buf, byteOffset)
    }

    export function decode (varint) {
      const int = decodeEnumerable(varint)

      return stringify(int) ?? int
    }

    export function encodingLength (value) {
      if (typeof value === 'string') return encodingLength(parse(value))
      assert(value != null, 'Invalid ${name} value (' + value + ')')

      ${enumMaxBytes === ENUM_ENCODING_MAX_BYTES
? `
        // This enum may fully consume the max allowed size
        return ${ENUM_ENCODING_MAX_BYTES}
      `
: join`
        if (${enumMinValue} <= value && value <= ${enumMaxValue}) return ${enumMaxBytes}

        // enumerable max value in case of unknown value
        return ${ENUM_ENCODING_MAX_BYTES}
      `}
    }

    /**
     * Convert an enum value to it's human readable name.
     * Returns undefined on an unknown value.
     */
    export function stringify (int) {
      return enumValues.get(int)
    }

    /**
     * Convert an enum string names to it's machine integer value.
     * Returns undefined on an unknown name.
     */
    export function parse (str) {
      return enumNames.get(str)
    }
  `
}
